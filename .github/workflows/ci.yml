# SPDX-FileCopyrightText: 2025 RAprogramm
# SPDX-License-Identifier: MIT

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: -D warnings

jobs:
  # Stage 1: Detect changes
  detect:
    uses: ./.github/workflows/_detect.yml

  # Stage 2: PR size check (blocks other checks on failure)
  pr-size:
    needs: detect
    uses: ./.github/workflows/_pr-size.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  # Stage 3: Linting (parallel)
  fmt:
    needs: [detect, pr-size]
    if: always() && (needs.pr-size.result == 'success' || needs.pr-size.result == 'skipped')
    uses: ./.github/workflows/_fmt.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  clippy:
    needs: detect
    uses: ./.github/workflows/_clippy.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  # Stage 4: Quality and tests (after linting)
  qual:
    needs: [detect, fmt, clippy]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped') && (needs.clippy.result == 'success' || needs.clippy.result == 'skipped')
    uses: ./.github/workflows/_qual.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  test:
    needs: [detect, fmt, clippy]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped') && (needs.clippy.result == 'success' || needs.clippy.result == 'skipped')
    uses: ./.github/workflows/_test.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}
    secrets:
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  doc:
    needs: [detect, fmt, clippy]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped') && (needs.clippy.result == 'success' || needs.clippy.result == 'skipped')
    uses: ./.github/workflows/_doc.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  doctest:
    needs: [detect, fmt, clippy]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped') && (needs.clippy.result == 'success' || needs.clippy.result == 'skipped')
    uses: ./.github/workflows/_doctest.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  # Stage 4: Security and compliance (parallel with tests)
  audit:
    needs: detect
    uses: ./.github/workflows/_audit.yml
    with:
      deps_changed: ${{ needs.detect.outputs.deps }}

  deny:
    needs: detect
    uses: ./.github/workflows/_deny.yml
    with:
      deps_changed: ${{ needs.detect.outputs.deps }}

  reuse:
    needs: detect
    uses: ./.github/workflows/_reuse.yml
    with:
      reuse_changed: ${{ needs.detect.outputs.reuse }}

  # Stage 4: Compatibility checks (parallel with tests)
  msrv:
    needs: [detect, fmt]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped')
    uses: ./.github/workflows/_msrv.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  semver:
    needs: [detect, fmt, clippy]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped') && (needs.clippy.result == 'success' || needs.clippy.result == 'skipped')
    uses: ./.github/workflows/_semver.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  machete:
    needs: [detect, fmt]
    if: always() && (needs.fmt.result == 'success' || needs.fmt.result == 'skipped')
    uses: ./.github/workflows/_machete.yml
    with:
      deps_changed: ${{ needs.detect.outputs.deps }}

  # Stage 5: Build (after all checks pass)
  build:
    needs: [detect, test, doc, audit, deny, reuse, msrv, machete, doctest, qual]
    if: |
      always() &&
      needs.detect.outputs.rust == 'true' &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      (needs.doc.result == 'success' || needs.doc.result == 'skipped') &&
      (needs.audit.result == 'success' || needs.audit.result == 'skipped') &&
      (needs.deny.result == 'success' || needs.deny.result == 'skipped') &&
      (needs.reuse.result == 'success' || needs.reuse.result == 'skipped') &&
      (needs.msrv.result == 'success' || needs.msrv.result == 'skipped') &&
      (needs.machete.result == 'success' || needs.machete.result == 'skipped') &&
      (needs.doctest.result == 'success' || needs.doctest.result == 'skipped') &&
      (needs.qual.result == 'success' || needs.qual.result == 'skipped')
    uses: ./.github/workflows/_build.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  # Stage 6: Changelog (only on main after build)
  changelog:
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.build.result == 'success'
    uses: ./.github/workflows/_changelog.yml

  # Stage 7: Tag release (after changelog)
  tag:
    needs: [build, changelog]
    if: |
      always() &&
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.build.result == 'success' &&
      (needs.changelog.result == 'success' || needs.changelog.result == 'skipped')
    uses: ./.github/workflows/_tag.yml

  # Stage 8: Release builds (only if new tag)
  release-build:
    needs: tag
    uses: ./.github/workflows/_release-build.yml
    with:
      new_tag: ${{ needs.tag.outputs.new_tag }}

  # Stage 9: Create release and publish (after release builds)
  release:
    needs: [tag, release-build]
    uses: ./.github/workflows/_release.yml
    with:
      new_tag: ${{ needs.tag.outputs.new_tag }}
      version: ${{ needs.tag.outputs.version }}

  publish:
    needs: [tag, release-build]
    uses: ./.github/workflows/_publish.yml
    with:
      new_tag: ${{ needs.tag.outputs.new_tag }}
    secrets:
      CRATES_IO_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}
