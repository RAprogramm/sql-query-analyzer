# SPDX-FileCopyrightText: 2025 RAprogramm
# SPDX-License-Identifier: MIT

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: -D warnings

jobs:
  # Stage 1: PR size check (blocks everything on failure)
  pr-size:
    name: PR Size Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - uses: RAprogramm/rust-prod-diff-checker@v1
        with:
          max_prod_lines: '200'
          output_format: github
          post_comment: 'true'
          fail_on_exceed: 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Stage 2: Detect changes
  detect:
    needs: pr-size
    if: |
      always() &&
      (github.event_name == 'push' || needs.pr-size.result == 'success')
    uses: ./.github/workflows/_detect.yml

  # Stage 3: All checks (parallel)
  fmt:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_fmt.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  clippy:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_clippy.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  qual:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    permissions:
      contents: read
      pull-requests: write
    uses: ./.github/workflows/_qual.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  test:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_test.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}
    secrets:
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  doc:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_doc.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  doctest:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_doctest.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  audit:
    needs: detect
    if: needs.detect.outputs.deps == 'true'
    uses: ./.github/workflows/_audit.yml
    with:
      deps_changed: ${{ needs.detect.outputs.deps }}

  deny:
    needs: detect
    if: needs.detect.outputs.deps == 'true'
    uses: ./.github/workflows/_deny.yml
    with:
      deps_changed: ${{ needs.detect.outputs.deps }}

  reuse:
    needs: detect
    if: needs.detect.outputs.reuse == 'true'
    uses: ./.github/workflows/_reuse.yml
    with:
      reuse_changed: ${{ needs.detect.outputs.reuse }}

  msrv:
    needs: detect
    if: needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_msrv.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  semver:
    needs: detect
    if: github.event_name == 'pull_request' && needs.detect.outputs.rust == 'true'
    uses: ./.github/workflows/_semver.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  machete:
    needs: detect
    if: needs.detect.outputs.deps == 'true'
    uses: ./.github/workflows/_machete.yml
    with:
      deps_changed: ${{ needs.detect.outputs.deps }}

  # Stage 4: Build (after all checks pass)
  build:
    needs: [detect, fmt, clippy, qual, test, doc, doctest, audit, deny, reuse, msrv, machete]
    if: |
      always() &&
      needs.detect.outputs.rust == 'true' &&
      (needs.fmt.result == 'success' || needs.fmt.result == 'skipped') &&
      (needs.clippy.result == 'success' || needs.clippy.result == 'skipped') &&
      (needs.qual.result == 'success' || needs.qual.result == 'skipped') &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      (needs.doc.result == 'success' || needs.doc.result == 'skipped') &&
      (needs.doctest.result == 'success' || needs.doctest.result == 'skipped') &&
      (needs.audit.result == 'success' || needs.audit.result == 'skipped') &&
      (needs.deny.result == 'success' || needs.deny.result == 'skipped') &&
      (needs.reuse.result == 'success' || needs.reuse.result == 'skipped') &&
      (needs.msrv.result == 'success' || needs.msrv.result == 'skipped') &&
      (needs.machete.result == 'success' || needs.machete.result == 'skipped')
    uses: ./.github/workflows/_build.yml
    with:
      rust_changed: ${{ needs.detect.outputs.rust }}

  # Stage 5: Changelog (only on main after build)
  changelog:
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.build.result == 'success'
    permissions:
      contents: write
    uses: ./.github/workflows/_changelog.yml

  # Stage 6: Tag release (after changelog)
  tag:
    needs: [build, changelog]
    if: |
      always() &&
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.build.result == 'success' &&
      (needs.changelog.result == 'success' || needs.changelog.result == 'skipped')
    permissions:
      contents: write
    uses: ./.github/workflows/_tag.yml

  # Check if release should proceed
  should-release:
    needs: tag
    if: always() && needs.tag.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      release: ${{ steps.check.outputs.release }}
      version: ${{ needs.tag.outputs.version }}
    steps:
      - name: Check if new tag
        id: check
        run: |
          echo "new_tag='${{ needs.tag.outputs.new_tag }}'"
          echo "version='${{ needs.tag.outputs.version }}'"
          if [ "${{ needs.tag.outputs.new_tag }}" = "true" ]; then
            echo "release=true" >> $GITHUB_OUTPUT
          else
            echo "release=false" >> $GITHUB_OUTPUT
          fi

  # Stage 7: Release builds (only if new tag)
  release-build:
    needs: should-release
    if: always() && needs.should-release.result == 'success' && needs.should-release.outputs.release == 'true'
    uses: ./.github/workflows/_release-build.yml
    with:
      new_tag: ${{ needs.should-release.outputs.release }}

  # Stage 8: Create release and publish (after release builds)
  release:
    needs: [should-release, release-build]
    if: always() && needs.should-release.result == 'success' && needs.should-release.outputs.release == 'true' && needs.release-build.result == 'success'
    permissions:
      contents: write
    uses: ./.github/workflows/_release.yml
    with:
      new_tag: ${{ needs.should-release.outputs.release }}
      version: ${{ needs.should-release.outputs.version }}

  publish:
    needs: [should-release, release-build]
    if: always() && needs.should-release.result == 'success' && needs.should-release.outputs.release == 'true' && needs.release-build.result == 'success'
    uses: ./.github/workflows/_publish.yml
    with:
      new_tag: ${{ needs.should-release.outputs.release }}
    secrets:
      CRATES_IO_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}
